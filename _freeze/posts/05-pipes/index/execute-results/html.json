{
  "hash": "372c99436012467eefc6af81845f1890",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: 'How much do you know about pipes?'\nsubtitle: 'History and Functionality of pipes'\ndate: \"2025-11-10\"\nimage: \"image.jpg\"\ncategories: [R, pipes, tidyverse, programming]\nformat:\n    html:\n        toc: true\n        toc-float: true\n        toc-depth: 3\n        number-sections: true\n        code-fold: false\n        code-tools: false\n        theme: default\n        fig-width: 10\n        fig-height: 6\n        fig-cap-location: bottom\nexecute:\n    echo: true\n    message: false\n    warning: false\n    fig-align: center\n    fig-width: 10\n    fig-height: 6\nfilters: \n    - social-share\nshare:\n    permalink: \"https://joshuamarie.com/posts/05-pipes/\"\n    description: \"Pipes in R - Joshua Marie\"\n    twitter: true\n    facebook: true\n    reddit: true\n    stumble: true\n    tumblr: true\n    linkedin: true\n    email: true\n    mastodon: true\n    bsky: true\n    location: \"before-body\"\n---\n\n# Pledge\n\nI'll go dive about the history of pipes in R. Pipes have revolutionized the way we write R code, making it more readable and maintainable. But the story of pipes in R is richer than many realize. While most R users are already familiar with `{magrittr}`'s `%>%` or the native R `|>`, the journey of pipes in R spans multiple packages and years of implementations, each with unique features and use cases.\n\nIn this post, I'll be chronological about what I explore in the history and variety of pipes available in R, from the pioneering days to modern implementations.\n\n*But the question still remains: How much did you really learn about pipes in R? *\n\n# Brief Definition before starting\n\nA **pipe** operator is a binary operator, just like `+`, that passes the output of one function as the input to the another expression. In R, it mimics Python's method chaining:\n\n:::: panel-tabset\n\n## R\n\ni.  Without breaking into another line: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nx |> f() |> g() |> h()\n```\n:::\n\n\nii.  Breaking into next line:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx |> \n    f() |> \n    g() |> \n    h()\n```\n:::\n\n\n## Python\n\ni.  Without breaking into another line: \n\n``` python\nx.f().g().h()\n```\n\nii.  Breaking into next line:\n\n``` python\nx \\\n    .f() \\\n    .g() \\\n    .h()\n    \n(\n    x\n      .f() \n      .g() \n      .h()\n)\n```\n\n::: callout-note\nIn Python, you can't break the code into another line, unless `\\` between the methods, or closing the expression with `()` is applied. As you can see, R is more forgiving and a lot better than Python, because it is only bounded in its class. \n:::\n\n::::\n\nIt lets you at least avoid creating intermediate variables and write code that reads from **left to right** — Usually, some documentation refers it as left-hand side (LHS) and right-hand side (RHS), respectively.\n\n# The Early Days: Pre-Pipe Workflows (≤2010)\n\nBefore pipes, the usual workflow in R relies on the following on nested function calls:\n\ni. Nested function calls\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(mean(c(1, 2, 3, 4, 5)), 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\nThis would be difficult to read and maintain once the function calls get deeper\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(mean(log(c(1, 2, 3, 4, 5))), 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.96\n```\n\n\n:::\n:::\n\n\nii.  Intermediate variables\n\nInstead of a deep nested call\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(1, 2, 3, 4, 5)\nlog_x = log(x)\nmu_x = mean(log_x)\nmu_x_rounded = round(mu_x, 2)\nmu_x_rounded\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.96\n```\n\n\n:::\n:::\n\n\nMy problem with *intermediate variables* is that it is cluttered with temporary variables.\n\n# Timeline of R Pipes\n\nMany of R developers in the past invented pipes, like many times. Let's explore them chronologically. \n\nSee how pipes evolved from experimental packages to core R:\n\n![](pipes-timeline.png)\n\n## 1. The **{pipeR}** Pioneer (2013)\n\nThe `{pipeR}` package by Kun Ren was one of the earliest pipe implementations in R, introducing the `%>>%` operator.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbox::use(pipeR[`%>>%`])\n\n1:10 %>>%\n    mean() %>>%\n    round(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.5\n```\n\n\n:::\n:::\n\n\nHere's the cool part: \n\ni.  Lambda expressions with parentheses:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:10 %>>%\n    (mean(.) * 2) %>>%\n    round(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11\n```\n\n\n:::\n:::\n\n\nii.  Side effects with continued piping:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\nrnorm(100) %>>%\n    (~ plot(., main = \"Random Normal Values\")) %>>%  # Side effect\n    mean() %>>%\n    round(2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=960}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.09\n```\n\n\n:::\n:::\n\n\n::: {.callout-note title=\"Why it faded\"}  \nIt's not like it vanished from the existence, more like it is superseded by `{magrittr}` and took over. \n:::\n\n## 2. The Game Changer: **{magrittr}** Pipe (2014)\n\nThe `{magrittr}` package, created by Stefan Milton Bache and later maintained by Lionel Henry at Posit (formerly RStudio), became the most popular pipe implementation. It was inspired by F#'s pipe-forward operator and Unix pipes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbox::use(magrittr[`%>%`, `%<>%`, `%T>%`, `%$%`, `%!>%`])\n\nc(1, 2, 3, 4, 5) %>%\n    mean() %>%\n    round(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\nDo you know? There are plenty pipe operators in `{magrittr}` package, consists of at least 5 operators. Here are the special features: \n\n:::: panel-tabset\n\n### The classic\n\nThe `%>%` is `{magrittr}`'s standard and \"lazy\" pipe - it doesn't evaluate arguments until needed, which can affect behavior with certain functions. Lazy evaluation means that the RHS is only computed when its value is required, which optimizes performance but can lead to surprises with side-effect-heavy code.\n\nTo understand better how `%>%` works, let's give a demonstration by applying dot placeholder for non-first arguments: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars %>%\n    lm(mpg ~ cyl, data = .)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = mpg ~ cyl, data = .)\n\nCoefficients:\n(Intercept)          cyl  \n     37.885       -2.876  \n```\n\n\n:::\n:::\n\n\nThe dot (`.`) acts as a placeholder for the piped value, allowing it to be inserted into any argument position—not just the first. You can also apply multiple placeholders:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars %>% \n    head(5) %>% \n    split(., .$cyl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$`4`\n            mpg cyl disp hp drat   wt  qsec vs am gear carb\nDatsun 710 22.8   4  108 93 3.85 2.32 18.61  1  1    4    1\n\n$`6`\n                mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4      21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag  21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nHornet 4 Drive 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\n\n$`8`\n                   mpg cyl disp  hp drat   wt  qsec vs am gear carb\nHornet Sportabout 18.7   8  360 175 3.15 3.44 17.02  0  0    3    2\n```\n\n\n:::\n:::\n\n\n### Assignment pipe\n\nThe `%<>%` operator is invoking reference semantics, where it pipes and assigns the result back to the original variable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = 1:5\nx %<>% log() %>% sum()\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.787492\n```\n\n\n:::\n:::\n\n\nThis is equivalent to `x = x %>% log() %>% sum()` but more concise. What happened here is we created a side-effect of `x`. Some [pointed](https://www.reddit.com/r/rstats/comments/f77mjv/why_are_the_and_pipes_magrittr_not_used_with_dplyr/) it out why it is a problem. \n\n### Tee pipe\n\nThe `%T>%` \"tee\" pipe passes the left-hand side value forward, not the output of the right-hand side. Useful for side effects like plotting or printing, where you want to perform an action but continue with the original data: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\nrnorm(100) %T>% \n    plot(main = \"Values before mean\") %>% \n    mean() %>%\n    round(2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=960}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.09\n```\n\n\n:::\n:::\n\n\nThis should be the equivalent:\n\n``` r \n{\n    set.seed(123)\n    plot(rnorm(100), main = \"Values before mean\")\n    round(mean(rnorm(100)), 2)\n}\n```\n\nSo, if you try the following:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:5 %T>% \n    mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n:::\n\n\nThe `%T>%` operator discards the output of `mean(1:5)`, and that's because `mean()` doesn't return a side-value effect. \n\nBy the way, the \"tee\" name comes from Unix's `tee` command, which splits output streams.\n\n### Exposition pipe\n\nThe `%$%` \"exposition\" pipe exposes the names within the left-hand side object to the right-hand side expression:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars %$%\n    cor(mpg, cyl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -0.852162\n```\n\n\n:::\n:::\n\n\nThis is equivalent to:\n\n``` r\ncor(mtcars$mpg, mtcars$cyl)\n```\n\nThis is particularly useful with functions that don't have a `data` argument.\n\n::: callout-warning\nDo not use `%$%` operator when LHS is not a a list or data frame with named elements. \n:::\n\n### Eager pipe\n\nThe `%!>%` operator is the \"eager\" version of `%>%` that evaluates arguments *immediately*. This can matter for functions with non-standard evaluation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Standard (lazy) pipe\niris %>% \n    subset(Species == \"setosa\") %>% \n    head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n```\n\n\n:::\n\n```{.r .cell-code}\n# Eager pipe (forces immediate evaluation)\niris %!>% \n    subset(Species == \"setosa\") %!>% \n    head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n```\n\n\n:::\n:::\n\n\nIn most cases, the difference is subtle, but it can matter for advanced programming.\n\nTo see the actual difference: \n\ni.  `%!>%`: `cat(1)` is immediately evaluated (it evaluates from left to right)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n0 %!>% (\\(x) { cat(1); x }) %!>% (\\(x) cat(2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n12\n```\n\n\n:::\n:::\n\n\nii.  `%>%`: Evaluates only `cat(2)` as the first result is never used\n\n\n::: {.cell}\n\n```{.r .cell-code}\n0 %>% (\\(x) { cat(1); x }) %>% (\\(x) cat(2))  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n2\n```\n\n\n:::\n:::\n\n\nSource: https://stackoverflow.com/questions/76326742/what-are-the-differences-and-use-cases-of-the-five-magrittr-pipes\n\n::::\n\n## 3. The **{wrapr}** Dot Arrow (2017)\n\nJohn Mount's `{wrapr}` package provides the `%.>%` \"dot arrow\" pipe, a deliberate and explicit alternative to `%>%`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbox::use(wrapr[`%.>%`])\n\n1:10 %.>%\n    mean(.) %.>%\n    round(., 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.5\n```\n\n\n:::\n:::\n\n\nI don't know much about this pipe, to be honest. As what I can see, this pipe requires the dot to always be explicit, which, for me, it's so good that it can prevent some subtle bugs and makes code intentions clearer. \n\n## 4. The Bizarro Pipe (Base R, ~2017)\n\nI am not sure when this operator released, but there's a pipe operator (not categorically) in base R: the \"Bizarro pipe\" (`->.; `), that works like `%>%` and `%.>%`. It's not a formal operator but an emergent behavior from combining existing R syntax.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:10 ->.; \n    mean(.) ->.; \n    round(., 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.5\n```\n\n\n:::\n:::\n\n\nThe Bizarro pipe works by:\n\n1. Using right assignment `->` to assign to `.` (this is done by typing `-` + `>` + `.`)\n2. Ending each statement with `;` to separate expressions\n3. The next line uses `.` as input\n\nIt's called \"Bizarro\" because it uses right-to-left assignment syntax (`->`) to create a left-to-right workflow. \n\nHowever, it has disadvantages (talked in this [Stackoverflow](https://stackoverflow.com/a/67868877) discussion):\n\n- Creates hidden side-effects (the persistent `.` variable)\n- Goes against R style guides (right assignment and semicolons are discouraged)\n- Can lead to subtle bugs if you forget to assign to `.` at some step\n- The `.` variable is hidden from `ls()` and IDE inspectors\n- It's so pesky, it won't auto-indent \n\nSeriously, I won't recommend Bizarro pipe at all. It is still a nice touch as a temporary replacement of `%>%` for chained R codes, and will not use it for production code.\n\n## 5. The Native Pipe (R v4.1+, 2021)\n\nIn May 2021, R v4.1 introduced the native pipe operator `|>` (type `|` and `>`), bringing pipe functionality into base R without the need for external packages. This operator is the actual operator that was inspired by the pipe-forward operator in F# and the concept of Unix pipes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, 2, 3, 4, 5) |>\n    mean() |>\n    round(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\nThis is too identical to `%>%` from `{magrittr}` with some obvious differences. \n\n### Common differences from `{magrittr}` pipe\n\nThe placeholder for `|>` is now applied in R v4.2 and above. For the syntax, it rather uses `_`, not `.`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars |>\n    lm(mpg ~ cyl, data = _)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = mpg ~ cyl, data = mtcars)\n\nCoefficients:\n(Intercept)          cyl  \n     37.885       -2.876  \n```\n\n\n:::\n:::\n\n\nThe native pipe:\n\n- Is slightly faster (negligible in often cases, this matters for some cases like running for-loop)\n- Does not support the tee (`%T>%`), exposition (`%$%`), or assignment (`%<>%`) operators\n- Cannot be used with compound assignment\n- Is more strict about valid syntax\n\n### Performance comparison\n\nThe native pipe is clearly faster than the `{magrittr}` pipe because native pipe does not add more function calls within its implementation compared to the `{magrittr}` pipe. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(\n    \"magrittr pipe\" = replicate(10000, 1:100 %>% sum()), \n    \"native R pipe\" = replicate(10000, 1:100 |> sum())\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 6\n  expression         min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr>    <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 magrittr pipe   44.8ms   44.8ms      22.3     375KB    100. \n2 native R pipe   10.6ms   12.3ms      81.0     369KB     45.8\n```\n\n\n:::\n:::\n\n\n### Pipe-bind operator\n\nAfter R v4.2, the pipe-bind operator `=>` (type `=` + `>`), or a pipe-binding syntax, allows you to bind the result of the left-hand side (LHS) to a name within the right-hand side (RHS) expression.\n\nThis feature is, however, disabled by default. You may want to enable it by running the following:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSys.setenv(\"_R_USE_PIPEBIND_\" = TRUE)\n```\n:::\n\n\nAnother options: \n\ni.  Place this command into `.Renviron` file (Hint: run `usethis::edit_r_environ()`):\n\n``` bash\n_R_USE_PIPEBIND_=true\n```\n\nii.  Run this in a command prompt or PowerShell\n  \n``` powershell\nsetx _R_USE_PIPEBIND_ true\n```\n\nIf you are in Linux / macOS (bash / zsh):\n\n``` bash\nexport _R_USE_PIPEBIND_=true\n```\n  \nThen restart R. \n\nHere's what it does:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars |> \n    df => lm(mpg ~ wt, data = df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = mpg ~ wt, data = df)\n\nCoefficients:\n(Intercept)           wt  \n     37.285       -5.344  \n```\n\n\n:::\n\n```{.r .cell-code}\nmtcars |> \n    df => split(df, df$cyl) |> \n    lapply(\\(df) lm(mpg ~ wt, data = df)) |> \n    vapply(\\(mod) summary(mod)$r.squared, numeric(1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        4         6         8 \n0.5086326 0.4645102 0.4229655 \n```\n\n\n:::\n:::\n\n\nThe `df` name temporarily exists only inside that RHS expression — not in your global environment. I like this because this is more explicit than `.` in `%>%` operator. You can name the LHS result and refer to it directly inside the RHS expression anything you like.\n\n## Non-Pipe Alternatives\n\nWhile the above are true pipe operators, it's worth mentioning that some packages achieve similar left-to-right workflows through different mechanisms.\n\n### Chaining in **{data.table}** (2010)\n\n`{data.table}` uses method chaining with `[][]` notation. It is NOT a pipe operator in a sense, but achieves a similar left-to-right flow. It behaves differently from the pipe operator — it chains operations within the same `[.data.table` method, and doesn't pass values between functions, i.e. the use of placeholders.\n\nLet's look at the basic `{data.table}` example: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nbox::use(data.table[as.data.table, `:=`])\n\ndt = as.data.table(mtcars)\ndt[cyl == 8][order(-mpg)][, .(mpg, cyl, hp)][1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     mpg   cyl    hp\n   <num> <num> <num>\n1:  19.2     8   175\n2:  18.7     8   175\n3:  17.3     8   180\n4:  16.4     8   180\n5:  15.8     8   264\n```\n\n\n:::\n:::\n\n\nDeeper method chaining in `{data.table}` with grouping and aggregation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[, log_mpg := log(mpg)][,\n    .(\n        mpg_mean = mean(mpg, na.rm = TRUE), \n        log_mpg_mean = mean(log_mpg, na.rm = TRUE)\n    ), by = cyl\n][\n    order(-mpg_mean, -log_mpg_mean)\n]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     cyl mpg_mean log_mpg_mean\n   <num>    <num>        <num>\n1:     4 26.66364     3.270454\n2:     6 19.74286     2.980439\n3:     8 15.10000     2.700171\n```\n\n\n:::\n:::\n\n\nThis is method chaining, not piping—the key difference is that pipes pass values between different functions, while `{data.table}` chains operations within the same `[` method.\n\n### Multiple Assignment with **{zeallot}** (2018)\n\nThis is not exactly an operator that behaves like a pipe, where it passes LHS as an input for RHS, but I would like to point this one out. R lacks destructuring (also called \"unpacking\") method, just like what you see in other languages, such as Python:\n\n``` python\nx, y = 0, 1\n```\n\nThe `{zeallot}` allows destructuring assignment with `%<-%`. While not exactly a pipe operator to chain the commands, works well in pipe-like workflows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbox::use(zeallot[`%<-%`])\n\n# Multiple assignment\nc(a, b) %<-% c(1, 2)\nc(a, b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2\n```\n\n\n:::\n:::\n\n\nDestructuring with computations:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(mean_val, sd_val, n) %<-% local ({\n    set.seed(125)\n    x = rnorm(100)\n    c(mean(x), sd(x), length(x))\n})\n\ncat(glue::glue(\"Mean: {mean_val}, SD: {sd_val} , N: {n}\"), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMean: 0.100208694251594, SD: 1.06105719788861 , N: 100 \n```\n\n\n:::\n:::\n\n\nWorks with pipe workflows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\nc(m, s) %<-% (rnorm(100) %>% { c(mean(.), sd(.)) })\nc(m, s)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.09040591 0.91281588\n```\n\n\n:::\n:::\n\n\n# Acknowledgment\n\nI would like to thank the [r/rstats](https://www.reddit.com/r/rstats/) community for engaging my article about the pipes in R. I would like to thank [u/guepier](https://www.reddit.com/user/guepier/) for pointing out the actual pipe history, where there's actually a pipe that predates both `{pipeR}` and `{magrittr}` in this [comment](https://www.reddit.com/r/rstats/comments/1ouvesz/comment/nof96n6/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button).   \n\nSpecial thanks to the developers of `{magrittr}`, `{pipeR}`, `{wrapr}`, and the R core team for introducing the native pipe operator.\n\n# Remarks and Resources\n\nAs you can see, it needs a lot to came up with lots of crufts and inventions, after years of invention. The native pipe came up later after the release of R v4.1 in May 2021, thanks to the popularization of `{magrittr}` and `{tidyverse}`. And that's all I know about pipes in R.  \n\nHere are the additional resources: \n\n- [magrittr documentation](https://magrittr.tidyverse.org/)\n- [R - Release Notes](https://cran.r-project.org/doc/manuals/r-release/NEWS.html)\n- [pipeR package](https://renkun-ken.github.io/pipeR/)\n- [wrapr package](https://winvector.github.io/wrapr/)\n- [data.table documentation](https://rdatatable.gitlab.io/data.table/)\n- [zeallot package](https://cran.r-project.org/package=zeallot)\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}