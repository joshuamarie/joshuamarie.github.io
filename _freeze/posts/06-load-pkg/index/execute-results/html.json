{
  "hash": "e08c7d497284c8be72d5f141b8858ba1",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: 'Ways to load / attach packages in R'\nsubtitle: 'Worst to best solution'\ndescription: \"A completely objective, totally scientific ranking (2025 edition)\"\ndate: \"2025-11-17\"\nimage: \"image.png\"\ncategories: [R, packages]\nformat:\n    html:\n        toc: true\n        toc-float: true\n        toc-depth: 3\n        number-sections: true\n        code-fold: false\n        code-tools: false\n        theme: default\n        fig-width: 10\n        fig-height: 6\n        fig-cap-location: bottom\nexecute:\n    echo: true\n    message: false\n    warning: false\n    fig-align: center\n    fig-width: 10\n    fig-height: 6\nfilters: \n    - social-share\nshare:\n    permalink: \"https://joshuamarie.com/posts/06-load-pkg/\"\n    description: \"Ways to load R packages - Joshua Marie\"\n    twitter: true\n    facebook: true\n    reddit: true\n    stumble: true\n    tumblr: true\n    linkedin: true\n    email: true\n    mastodon: true\n    bsky: true\n    location: \"before-body\"\n---\n\nIsn't it great that R has more than 1 solution to load packages? Some of them are beautiful. Some of them should be illegal in at least three countries.  Let’s rank them from “please never do this” to “finally, some good food.”\n\n![](image.png)\n\nIn this post, I will try enumerate the different ways to load packages in R, and discuss their pros and cons. I will also rank them from worst to best solution in practices.\n\n# Different ways to load / attach packages in R\n\nI sorted the different ways to load packages in R from worst to best solution in practices. This may be subjective, but I will try to justify my ranking based on the principles of good programming practices.\n\nThis is how I rank them from worst to best:\n\n| Rank | Method                                      | Verdict                                      |\n|------|---------------------------------------------|----------------------------------------------|\n| 9    | [`base::use()`](#base-use)                  | Experimental copium (now officially dead last) |\n| 8    | [`require()`](#require)                     | War criminal                                 |\n| 7    | [`{pacman}`](#pacman)                       | Convenience trap                             |\n| 6    | [`library()`](#library-classic)             | Boomer energy                                |\n| 5    | [`library() + conflicted`](#combo-pack)     | Manual gearbox in 2025                       |\n| 4    | [`::` everywhere](#double-colon)            | Professional wrist pain                      |\n| 3    | [`{import}`](#import-pack)                  | Extremely polite gentleman                   |\n| 2    | [`{box}`](#box)                             | The chosen one                               |\n| 1    | [`{box}` + coffee](#box)                    | Ascended plane of existence                  |                            |\n\n## The new **base::use()** function (v4.4.0+) {#base-use}\n\nUpdate: When I discover the bug, thanks to [u/guepier](https://www.reddit.com/user/guepier/) and his [comment](https://www.reddit.com/r/rstats/comments/1p1y89p/comment/nptplse/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button), this changes my mind. Now, I put this in the worst place amongst the solution I listed here. \n\nI feel like R Core saw the chaos and said \"fine, we’ll do something\". This function is available in R version 4.4.0 and above, by the way. \n\nIt allows you to load packages in a way that minimizes namespace conflicts by only attaching the functions you explicitly use. Take note that `base::use()` is a short case of `library()`, a simple wrapper, where it keeps `include.only` and set: \n\n1.  `lib.loc` to `NULL`\n2.  `character.only` to `TRUE`\n3.  `logical.return` to `TRUE`\n4.  `attach.required` to `FALSE`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuse('pkg', c('obj1', 'fun1'))\n```\n:::\n\n\nThis is still `library()`, but granular imports are explicit. Except...\n\n![](problem-uh-oh.gif)\n\nAnother problem occurs: Remember, it is just a simple wrapper of `library()`, therefore the import still goes to the search path. \n\nIt's like putting a fancy new paint job on a 1987 Honda Civic and calling it a Ferrari. It LOOKS different, but under the hood, same old engine, baby.\n\nFor example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_data = function(.data) {\n    use('dplyr', 'summarise')\n    use('tidyr', 'pivot_longer')\n    \n    summarise(\n        .data, across(\n            where(is.numeric), \n            \\(col) mean(col, na.rm = TRUE)\n        )\n    ) |> \n        pivot_longer(\n            cols = where(is.numeric), \n            names_to = \"Variable\", \n            values_to = \"Ave\"\n        )\n}\n\nmean_data(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n  Variable       Ave\n  <chr>        <dbl>\n1 Sepal.Length  5.84\n2 Sepal.Width   3.06\n3 Petal.Length  3.76\n4 Petal.Width   1.20\n```\n\n\n:::\n:::\n\n\nAfter I execute `mean_data(iris)`, the imports are accessible *everywhere*. EVERYWHERE! \n\nAnd `base::use()` is still broken even in the latest R versions.\n\nLike, it is so completely broken:\n\n``` r \nuse('dplyr', 'mutate')\niris |> mutate(Petal.Area = Petal.Length * Petal.Width)\n#> Error in mutate(iris, Petal.Area = Petal.Length * Petal.Width) : \n#>   could not find function \"mutate\"\n```\n\n> The issue is that subsequent `library()` calls for an identical package are ignored, and the same is true for `base::use()`. Bananas. Completely broken.\n\n::: callout-note\nThis is noted by R core team:\n\n> This functionality is still experimental: interfaces may change in future versions.\n\n:::\n\n## Worst: Using **require()** {#require}\n\n![](meme1.jpg)\n\n~Just...no. I'll be making a hot take here that sounds controversial, but this solution is the worst thing ever existed in R to attach the packages. ~\n\nUpdate: This solution may be bad, but at least not worse than `base::use()`. \n\nThis function returns a Boolean value: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(pkg) |> \n    suppressMessages() |> \n    suppressWarnings() |> \n    print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\nIt returns `TRUE` if the package is successfully loaded and `FALSE` otherwise. \n\nAnd should only be applicable inside functions to check if a package is available. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncheck_package = function() {\n    if (require(pkg, quietly = TRUE)) {\n        print(\"Package loaded successfully\")\n    } else {\n        print(\"Package not available\")\n    }\n}\ncheck_package()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Package not available\"\n```\n\n\n:::\n:::\n\n\nUsing `require()` at the top of a script is how you get mysterious errors 50 lines later.\nOnly acceptable inside functions when you actually check the return value.\n\nSeriously, this is just `library()` where you can place it at the top level of your script, but add another extra steps. \n\n## The pro boxer: **{pacman}** {#pacman}\n\nThis guy will punch you to death. Just kidding, Manny Pacquiao is a great boxer :). The `{pacman}` package tries to streamline package management with functions like `p_load()`.\n\nDo you know this?\n\n``` r\nif (!require(pkg)) {\n    install.packages(\"pkg\")\n    library(pkg)\n}\n```\n\nWell, they made a shortcut, with `pacman::p_load()`:\n\n``` r\npacman::p_load(pkg)\n```\n\nYou can do the same as above, except you can do this for multiple packages. \n\nHere's how:\n\n``` r\npacman::p_load(pkg1, pkg2, pkg3)\n```\n\nSounds convenient, right? \n\n![](trap.gif)\n\nActually mixes two completely different responsibilities:\n\n-  Installation (one-time setup)\n-  Loading (analysis step)\n\nGreat for interactive playtime.\nDisastrous in scripts, packages, CI/CD, or any environment without internet.\nAlso: \n\n-   It violates the [single responsibility principle](https://en.wikipedia.org/wiki/Single-responsibility_principle), harder than a toddler with a drum kit.\n\n-   This is like a pineapple pizza \n\n    ![](lionfield-not-approved.gif)\n\n## The classic **library()** {#library-classic}\n\nSuch a classic function, isn't it? After all, this is the most used function to attach R package namespace. It is a standard practice that most R users use, and it is safe: It will throw an error if `pkg` is not installed. This function is traditional and simple:\n\n``` r\nlibrary(pkg)\n```\n\nThat's it, right? \n\nI hope it was that simple, but it has some serious downsides: \n\ni.  It attaches the entire package namespace to the *search path*, \nii.  It can lead to namespace clash, particularly if multiple packages have functions with the same name. This can make debugging difficult and lead to unexpected behaviors in your code.\niii.  It makes the imports unclear which functions come from which packages\niv.  All exported functions are available, even if you only need one or two\n\nTo detach the attached package namespace in the search path, use `detach()` function with `package : ` keyword:\n\n``` r\ndetach(package : pkg)\n```\n\n::: callout-warning\nBe minded that `library()` function still potentially silently fails, even though it will throw an error, unlike `require()` where silent fails are always prominent. \n:::\n\n## **library()** and **{conflicted}** package combo {#combo-pack}\n\nHow about forcing the search path to select / deselect the imports? Introducing `{conflicted}` package. \n\n![](meme2.jpg)\n\nIn this approach, I combine traditional `library()` with the `{conflicted}` package to explicitly handle namespace conflicts.\n\nHow good? For example, I prefer using `dplyr::filter()` over `stats::filter()`, but a bit later on, I want to use `stats::filter()` when I want to run time series. The `conflicted::conflict_prefer()` handles which you want to declare \"winners\" of conflicts.\n\nI'll make a scenario to make you understand: \n\n1.  I have no use with `stats::filter()` because I only want to keep the data frame based on the condition using `dplyr::filter()`, and I want to load the entire `{dplyr}` namespace. Here, I declare `dplyr::filter()` as \"winner\" of the conflict: \n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    library(dplyr)\n    \n    conflicted::conflict_prefer('filter', 'dplyr', 'stats')\n    filter(mtcars, cyl == 8)\n    ```\n    :::\n\n\n2.  Then, I stopped using `dplyr::filter()` because I want to perform time series modelling with linear filtering using `stats::filter()`. Re-state `stats::filter()` as the \"winner\" of the conflict:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    conflicted::conflict_prefer('filter', 'stats', 'dplyr')\n    filter(1:10, rep(1, 3))\n    ```\n    :::\n\n\nStill loads everything. Still global. Still manual work. In my standard, this is actually good, but still not enough because it never allows granular imports and import aliasing, and besides, I've had better. \n\n## Tedious but Explicit: The **::** Operator {#double-colon}\n\n![](everywhere-meme.jpg)\n\nBefore packages like `{box}` and `{import}` introduced alternative import systems to R, the `::` operator was (and still is) R's built-in way to explicitly reference functions from specific namespaces without loading entire packages.\n\nThe `::` operator is the most explicit base R solution for calling package functions. It's part of R's namespace system and requires no external dependencies - just base R.\n\nHere's how:  \n\n-   The syntax is `package::function()`, which tells R exactly which package to pull the function from without attaching that package to your search path.\n\nMost of us using R are definitely using this (I am reusing an example from [base::use](#base-use)): \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_data = function(.data) {\n    dplyr::summarise(\n        .data, across(\n            where(is.numeric), \n            \\(col) mean(col, na.rm = TRUE)\n        )\n    ) |> \n        tidyr::pivot_longer(\n            cols = where(is.numeric), \n            names_to = \"Variable\", \n            values_to = \"Ave\"\n        )\n}\n\nmean_data(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n  Variable       Ave\n  <chr>        <dbl>\n1 Sepal.Length  5.84\n2 Sepal.Width   3.06\n3 Petal.Length  3.76\n4 Petal.Width   1.20\n```\n\n\n:::\n:::\n\n\n::: {.callout-note title=\"Notice\"}\n> Noticed that I don't call `dplyr::` for `across()` and `where()`? I have a [blog](https://joshuamarie.github.io/joshuamarie/posts/04-tidyselect-helpers/) talking about this. \n\n:::\n\nThis is great, compared to the previous solutions, no external packages needed and works mostly in any R version. The problem is this is way too verbose and repetitive, especially with many function calls:\n\n``` r\nggplot2::ggplot(data, ggplot2::aes(date, y)) +\n    ggplot2::geom_point() + \n    ggplot2::geom_line() + \n    ggplot2::theme_minimal() + \n    ggplot2::labs(\n        x = \"Date (by month)\",\n        y = \"Value (in dollars)\", \n        title = \"Monthly Value in Dollar\"\n    )\n```\n\nBeing typing-intensive is why I called this solution \"tedious\". \n\n![](everywhere-meme.jpg)\n\nRespectable, but I bet nobody wants to type that many in 2025.\n\n## Second to best: **{import}** package {#import-pack}\n\n*It is so close!*\n\n![](almost-there-almost.jpg)\n\nThis package is made before `{box}`. So, before `{box}`, the `{import}` package is the best solution ever made, arrived to fix `library()`'s most egregious issues. Created by Stefan Milton Bache (of pipe fame), it brings selective imports to R without requiring a complete paradigm shift.\n\n::: panel-tabset\n\n### First Example\n\nThe first example is simple: Normal imports with aliases. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nimport::from(\n    dplyr, \n    select, rename, keep_when = filter, mutate, summarise, n\n)\nimport::from(tidyr, long = pivot_longer, wide = pivot_wider, drop_na)\nimport::from(ggplot2, diamonds, cut_width)\n\ndiamonds |> \n    keep_when(\n        cut %in% c(\"Ideal\", \"Premium\"), \n        carat > 1\n    ) |> \n    drop_na() |> \n    mutate(\n        price_per_carat = price / carat,\n        size_category = cut_width(carat, 0.5)\n    ) |> \n    select(carat, cut, color, price, price_per_carat, size_category) |> \n    wide(\n        names_from = cut,\n        values_from = price_per_carat,\n        values_fn = median\n    ) |> \n    summarise(\n        across(c(Ideal, Premium), \\(col) mean(col, na.rm = TRUE)),\n        n = n()\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  Ideal Premium     n\n  <dbl>   <dbl> <int>\n1 6494.   5978.  9951\n```\n\n\n:::\n:::\n\n\n### Symbol binding\n\nUse backticks around `%>%` since it is under [non-syntactic names](https://adv-r.hadley.nz/names-values.html#non-syntactic). \n\n\n::: {.cell}\n\n```{.r .cell-code}\nimport::from(dplyr, select, filter, mutate, summarise, n, relocate)\nimport::from(magrittr, `%>%`) \nimport::from(tidyr, long = pivot_longer, wide = pivot_wider, drop_na)\n\nmtcars %>% \n    filter(cyl == 6) %>% \n    mutate(\n        hp_per_cyl = hp / cyl,\n        efficiency = mpg / disp\n    ) %>% \n    select(mpg, disp, hp, hp_per_cyl, efficiency, everything()) %>% \n    summarise(\n        across(\n            c(mpg, hp_per_cyl, efficiency), \n            list(\n                mu = \\(x) mean(x, na.rm = TRUE), \n                sigma = \\(x) sd(x, na.rm = TRUE)\n            ), \n            .names = \"{.col}..{.fn}\"\n        ),\n        n = n()\n    ) %>% \n    long(\n        cols = contains(c(\"mu\", \"sigma\")), \n        names_sep = \"\\\\..\", \n        names_to = c(\"Variable\", \"Stat\"), \n        values_to = \"Est\"\n    ) %>% \n    wide(\n        names_from = Stat, \n        values_from = Est\n    ) %>% \n    relocate(n, .after = last_col()) %>%\n    mutate(\n        se = sigma / sqrt(n), \n        cv = sigma / mu\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 6\n  Variable       mu  sigma     n      se     cv\n  <chr>       <dbl>  <dbl> <int>   <dbl>  <dbl>\n1 mpg        19.7   1.45       7 0.549   0.0736\n2 hp_per_cyl 20.4   4.04       7 1.53    0.198 \n3 efficiency  0.112 0.0231     7 0.00872 0.206 \n```\n\n\n:::\n:::\n\n\n:::\n\nIt's so awesome. Why?\n\n1.  No masking\n2.  Explicit at the top\n3.  Works with roxygen2 (@importFrom)\n4.  Imports the pipe like any other function\n\nThere's still some limitations. Even though `{import}` provide necessities that solves my problem in R's import system - \n\n1.  It has no unifying solution to attach the imports in the current environment. In fact, `{import}` functions still attach imported functions to the parent environment (usually global). What I mean is that they're not truly scoped to a module or function. Thus, the use of `import::here()`: \n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    with(iris, {\n        import::here(stats, corr = cor)\n        \n        corr(Sepal.Length, Petal.Length)\n    })\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 0.8717538\n    ```\n    \n    \n    :::\n    :::\n\n    \n    The expression we made, `with(iris, { ... })` creates a temporary environment that disappears immediately. So `corr()` is placed exactly there, inside that temporary environment, and you cannot reuse `corr()` somewhere in the environment, even in the global environment\n    \n    ``` r\n    corr(1:10, 2:11)\n    #> Error in corr(1:10, 2:11) : could not find function \"corr\"\n    ```\n    \n    This is better than loading entire packages, but not as clean as lexical scoping.\n\n2.  The package was designed primarily for **CRAN packages**. File-based modules feel like an afterthought rather than a first-class feature. \n\n3.  It lacks support for *nested module hierarchies*. You can import from files with this package, but you can't organize modules into sophisticated directory structures with their own internal dependencies.\n\n4.  Unlike `{box}`, there's no way to import a whole package as an object without attaching names\n\n## The ergonomically superior **{box}** package {#box}\n\n![](gordon-ramsay-finally.gif)\n\n*Finally, some good food. *\n\n::: {.callout-note title=\"My impression\"}\nIn 2021, Konrad Rudolph looked at R’s prehistoric import system, said:\n\n> “This is rubbish”\n\n*Disclaimer: I don't know if he said it, I said this just for fun ;)*\n\nI strongly agree. And then dropped one of the magnum opus: `{box}` — he dropped it like Gordon Ramsay dropping a perfectly seared Wellington on the pass.\n:::\n\nThis isn't \"slightly nicer imports\" — it's a complete rethinking of how R package should be loaded, and R code should be organized and namespaced. It brings true module systems (like Python, JavaScript, or Ruby) to R. \n\nThere's 4 of a kind to import like a sane person:\n\n``` r \nbox::use(\n    purrr,                          # 1\n    tbl = tibble,                   # 2\n    dplyr = dplyr[filter, select],  # 3\n    stats[st_filter = filter, ...]  # 4\n)\n```\n\n> Source: https://github.com/klmr/box\n\n1.  Attached the names? Nah, even better: \n\n    -  Imports the entire `{purrr}` package as an *object*.  \n    -  Nothing goes into the search path.  \n    -  You use it as `purrr$map()`, `purrr$keep()`, etc.  \n    -  Zero risk of masking, zero pollution. Pure bliss.\n\n2.  Whole package? But make it *short*\n\n    -   Same vibe as 1, but you give the package a cute little nickname.\n    -   Now you write `tbl$tbl_df()`, `tbl$as_tibble()`, etc.  \n    -   Perfect when you hate typing `tibble::` but also hate global mess.\n\n3.  I want the whole namespace... but only some names in my face.\n\n    -   A killer move, actually: import the whole package as an object, and selectively attach only the functions you actually want to write naked.  \n    -   So your pipelines stay clean: `filter()`, `select()`, `mutate()` — all smooth, drama-free.\n    -   But when you need the weird stuff, you still have the entire namespace sitting there like:\n    \n        ```\n        dplyr$reconstruct_tibble_from_who_knows_what()\n        ```\n\n4. \"I refuse to be gaslit by `stats::filter()` ever again.\"\n\n    -   \"I want everything from `{stats}` (because base R is already everywhere), but `stats::filter()` is a war criminal that keeps fighting with `dplyr::filter()`.\" \n    -   So basically, everything from `{stats}` is attached, but rename that one cursed function to `st_filter()` so it never bites me again. \n    -   The `...` means \"everything else, with their original names\".\n\nBut wait, there's more! \n\nHere, watch the madness of how I apply `{box}` to load package deps:\n\n``` r\nbox::use(\n    dplyr[\n        select, rename, \n        keep_when = filter,   # rename because we want to avoid needless fighting\n        mutate, summarise, \n        across, everything\n    ],\n    tidyr[pivot_longer, pivot_wider, drop_na],\n    magrittr[`%>%`],          # yes, don't forget that the pipe is just another import\n    ggplot2[ggplot, aes, geom_point, theme_minimal, labs, ggsave],\n    lubridate[ymd, year, month, floor_date],\n    data.table[fread]         # because sometimes you need speed, not dignity\n)\n```\n\nLess `::` spam. No `package::function()` that makes your code look like it's been hit by shrapnel. Zero `library()` / `require()`.\n\nAnd then, the part that makes grown R programmers cry tears of joy — You are also allowed to reuse exported namespace from an R script or a folder as a module. \n\n``` r\nbox::use(\n    app/models/glm_fit[...],           # brings everything exported\n    app/plots/theme_pub[theme_pub],    # only the theme\n    app/utils/cleaning[clean_names, fix_dates],\n    ./secret_sauce                     # local folder / script = module\n)\n```\n\nWith `{box}`, you can create modules that encapsulate your code and its dependencies — another revolutionary and W move in R community. This package is making my life easier in managing and reuse code across different projects. \n\nThis approach aligns well with modern programming practices and helps to keep your codebase clean and maintainable. \n\n### Little resources\n\nOther resources to learn more about this package:\n\n1.  [CRAN Index](https://cran.r-project.org/web/packages/box/index.html)\n2.  [Box README](https://klmr.me/box/)\n3.  [My book](https://joshuamarie.github.io/modules-in-r/)\n\n# Remarks\n\nWhile there are multiple ways to load packages in R, not all methods are created equal — some were created more equal than others, and some were created as war crimes. The choice of method can significantly impact the readability, maintainability, and reliability of your code, as well as your blood pressure and willingness to live. \n\nI strongly recommend using the `{box}` package in your projects, personal or not, for its modular approach and ability to avoid namespace clashes, making it a superior choice for loading packages in R. Like, come on, it's 2025. We have smartphones that can detect if you're about to have a heart attack. We have AI that can write poetry. We should NOT still be debugging namespace conflicts like it's 2005.\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}