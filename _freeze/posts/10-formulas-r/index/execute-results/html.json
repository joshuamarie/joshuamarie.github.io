{
  "hash": "6f45e8483582c78df2b7e2e474a63379",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"What's so special about formulas in R\"\nsubtitle: \"Hidden secrets? Somewhat\"\ndate: \"2025-12-08\"\nimage: \"image.png\"\ncategories: [R, formulas, rlang, machine-learning, statistics]\ndescription: \"Let's discover how in the world it works\"\nformat:\n    html:\n        toc: true\n        toc-float: true\n        toc-depth: 3\n        number-sections: true\n        code-fold: false\n        code-tools: false\n        theme: default\n        fig-width: 10\n        fig-height: 6\n        fig-cap-location: bottom\nexecute:\n    echo: true\n    warning: false\n    message: false\nfilters:\n    - social-share\n    - collapse-output\nshare:\n    permalink: \"https://joshuamarie.com/posts/11-formulas-r\"\n    description: \"Formulas in R — Joshua Marie\"\n    twitter: true\n    facebook: true\n    reddit: true\n    stumble: true\n    tumblr: true\n    linkedin: true\n    email: true\n    mastodon: true\n    bsky: true\n    location: \"before-body\"\nengine: knitr\n---\n\n![](image.png)\n\nIf you've used R for any statistical modeling, I am certainly sure you've encountered formulas, like, by a lot. \n\nHowever, what if I told you they're generally everywhere? For example: \n\n1.  Linear model `lm(y ~ x)`\n2.  ggplot2's `facet_grid()` and `formula` from `geom_smooth()`: \n\n    ```\n    mtcars |> \n        ggplot(aes(wt, mpg, color = factor(cyl))) + \n        geom_point(size = 3, alpha = 0.7) + \n        theme_minimal(base_size = 12) +  \n        \n        # You can modify the existing formula\n        geom_smooth(\n            method = \"lm\", \n            formula = y ~ log(x), \n            se = TRUE, \n            alpha = 0.2, \n            linewidth = 1\n        ) + \n        \n        # Facet grid accepts formula for rows and cols as an argument\n        facet_grid(~ cyl) + \n        \n        scale_color_manual(\n            values = c(\"4\" = \"#2E86AB\", \"6\" = \"#A23B72\", \"8\" = \"#F18F01\"),\n            name = \"Cylinders\"\n        )\n    ```\n    \n3.  Machine learning with `{tidymodels}`'s `{recipes}` API, e.g.:\n\n    ``` r\n    df |> \n        recipe(y ~ x1 + x2 + x3) |> \n        step_normalize(all_numeric_predictors()) |> \n        step_corr(all_predictors(), threshold = 0.9)\n    ```\n\n\nThe application is not limited to statistical modelling per se, where it describes the relationship between the variables, whereas the left hand side is the dependent variable, while the right hand side is the independent variable, for example. Also, have you ever wondered what makes them tick?\n\nFormula `~` in R is just another tool, most particular in metaprogramming, where it captures expressions in runtime without evaluating them. \n\nCan we dive deep into what makes formulas special and how you can leverage them in your own code? \n\n# What exactly are the formulas?\n\nAt their core, formulas are R objects created with the `~` operator. They look simple:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf = y ~ x\nclass(f)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"formula\"\n```\n\n\n:::\n:::\n\n\nBut there's more than meets the eye. A formula is actually a call object that stores unevaluated expressions along with their environment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(f)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"language\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(f)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\nA formula typically has three parts:\n\n1. The tilde operator `~`\n2. The left-hand side (LHS) - optional\n3. The right-hand side (RHS) - required\n\nExample 1 contains both LHS and RHS: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nf1 = y ~ x + z\nf1[[1]]  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n`~`\n```\n\n\n:::\n\n```{.r .cell-code}\nf1[[2]]  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ny\n```\n\n\n:::\n\n```{.r .cell-code}\nf1[[3]]  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nx + z\n```\n\n\n:::\n:::\n\n\nExample 2 contains RHS but LHS:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf2 = ~ x + z\nf2[[1]]  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n`~`\n```\n\n\n:::\n\n```{.r .cell-code}\nf2[[2]]  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nx + z\n```\n\n\n:::\n:::\n\n\n::: callout-warning\nIt is okay to not have LHS, only RHS. It is definitely not okay to have LHS but RHS. \n:::\n\n# Truth: It doesn't have an exact meaning\n\nLet me clarify something upfront: formulas in R don't have a rigid, predefined meaning.  \n\nWhat I mean is this:\n\n-   The formula interface is deliberately vague. The `~` operator doesn't enforce any particular semantics; it just captures structure. What that structure *means* entirely depends on how you choose to interpret it. \n\nIn short: The formulas in R actually lean on what you exactly do it. \n\nYou can really do anything. For instance:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransform_data = function(data, ...) {\n    box::use(\n        rlang[f_lhs, f_rhs, enexprs, eval_tidy],\n        purrr[reduce], \n        tibble[tbl = as_tibble]\n    )\n    \n    dots = enexprs(...)\n    \n    new_data = reduce(dots, function(df, expr) {\n        col_name = as.character(f_lhs(expr))\n        operation = f_rhs(expr)\n        df[[col_name]] = eval_tidy(operation, data = df)\n        df\n    }, .init = data)\n    \n    tbl(new_data)\n}\n\niris |> \n    transform_data(\n        petal_ratio ~ Petal.Length / Petal.Width, \n        pr_2 ~ petal_ratio^2, \n        Species ~ as.integer(Species)\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 150 × 7\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species petal_ratio  pr_2\n          <dbl>       <dbl>        <dbl>       <dbl>   <int>       <dbl> <dbl>\n 1          5.1         3.5          1.4         0.2       1        7     49  \n 2          4.9         3            1.4         0.2       1        7     49  \n 3          4.7         3.2          1.3         0.2       1        6.5   42.2\n 4          4.6         3.1          1.5         0.2       1        7.5   56.2\n 5          5           3.6          1.4         0.2       1        7     49  \n 6          5.4         3.9          1.7         0.4       1        4.25  18.1\n 7          4.6         3.4          1.4         0.3       1        4.67  21.8\n 8          5           3.4          1.5         0.2       1        7.5   56.2\n 9          4.4         2.9          1.4         0.2       1        7     49  \n10          4.9         3.1          1.5         0.1       1       15    225  \n# ℹ 140 more rows\n```\n\n\n:::\n:::\n\n\nIn this example, I'm treating `~` like an assignment operator — the left side becomes the column name, and the right side defines the computation. This is completely different from the statistical modeling interpretation where formulas express variable relationships.\n\nIn `{tidyverse}`takes yet another approach, using formulas as anonymous function shorthand: \n\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map_int(1:10, ~ .x^2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]   1   4   9  16  25  36  49  64  81 100\n```\n\n\n:::\n:::\n\n\nHere's another example — a function that uses formulas to define probability distributions, assigning them directly into your environment:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ndefine_rv = function(...) {\n    box::use(\n        rlang[f_rhs, f_lhs, enexprs, env, caller_env, as_string], \n        purrr[walk]\n    )\n    \n    dots = enexprs(...)\n    distributions = env(\n        normal = function(mu, sigma) {\n            list(\n                density = \\(x) dnorm(x, mean = mu, sd = sigma),\n                cdf = \\(x) pnorm(x, mean = mu, sd = sigma), \n                quantile = \\(x) qnorm(x, mean = mu, sd = sigma), \n                generate = \\(x) rnorm(x, mean = mu, sd = sigma)\n            )\n        }, \n        uniform = function(min, max) {\n            list(\n                density = \\(x) dunif(x, min = min, max = max),\n                cdf = \\(x) punif(x, min = min, max = max), \n                quantile = \\(x) qunif(x, min = min, max = max), \n                generate = \\(x) runif(x, min = min, max = max)\n            )\n        }\n    )\n    \n    target_env = caller_env()\n    \n    walk(dots, \\(f) {\n        var = as_string(f_lhs(f))\n        dist = f_rhs(f)\n        \n        rv_object = eval(dist, envir = distributions)\n        \n        assign(var, rv_object, pos = target_env)\n    })\n}\n```\n:::\n\n\nLet's give it a try:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nbox::use(\n    ggplot2[\n        ggplot, aes, theme_minimal, theme, geom_point, \n        element_text, element_blank, element_line, labs\n    ]\n)\n\ndefine_rv(\n    x ~ normal(0, 1), \n    y ~ uniform(0, 1)\n)\n\nset.seed(123)\nggplot() + \n    aes(x$generate(100), y$generate(100)) + \n    geom_point(color = \"#F5AFAF\", size = 3) + \n    theme_minimal(base_size = 20) + \n    labs(\n        x = \"Normally distributed\", \n        y = \"Uniformly distributed\", \n        title = \"Try visualizing it\", \n        subtitle = \"Generate up to 100 samples\"\n    ) + \n    theme(\n        plot.title = element_text(color = \"grey40\", face = \"bold\", size = 15), \n        plot.subtitle = element_text(color = \"grey40\", size = 13),\n        panel.grid.minor = element_blank(),\n        panel.grid.major = element_line(color = \"grey90\", linewidth = 0.3),\n        axis.title = element_text(face = \"bold\"),\n        axis.text = element_text(color = \"grey30\", size = 8), \n        axis.title.x = element_text(color = \"grey30\", size = 12), \n        axis.title.y = element_text(color = \"grey30\", size = 12)\n    )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=960}\n:::\n:::\n\n\n*That's how vague the true definition of the formula is. *\n\nLike I said in the intro, formula `~` in R is just another tool, without an exact meaning. In my application you see, it is most particular in metaprogramming, where it captures expressions without or before evaluating them. \n\n# The ancestor of quosures\n\nBack in 2017, the `{rlang}` package arrived with an ambitious goal: refine and modernize base R's metaprogramming tools. One of its key innovations — quosures — draws direct inspiration from R's formula system.\n\n## It captures both the expression and the environment\n\nThe formulas themselves are, in fact, objects, which means you can extract and manipulate the expressions they contain. But they also carry something \"hidden\": their environment. This dual nature: code plus context, is exactly what inspired quosures in `{rlang}`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nf = y ~ x + z\nenvironment(f)\n#>> <environment: R_GlobalEnv>\n```\n:::\n\n\nYou can even set a custom environment: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nf_custom = y ~ x\nenvironment(f_custom) = rlang::env(x = 10, y = 20)\nenvironment(f_custom)\n#>> <environment: 0x000001db174bd0b0>\n```\n:::\n\n\n*Unless needed, don't try this in your applications*\n\nEnvironment capture enables delayed evaluation. When you create a formula inside a function, it retains a snapshot of where it was born:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreate_formula = function(multiplier) {\n    ~ .x * multiplier\n}\n\nf_mult = create_formula(5)\nenvironment(f_mult)$multiplier  # The formula remembers!\n#>> [1] 5\n```\n:::\n\n\n> The `environment(f_mult)$multiplier` actually remembers!\n\n## Difference between \"~\" and quo\n\nBoth formulas and quosures are language objects at their core, but they differ in their class structure: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(y ~ x)\n#>> [1] \"formula\"\n```\n:::\n\n\nMeanwhile, `quo()` returns an object with dual inheritance — it's both a quosure *and* a formula:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(rlang::quo(y))\n#>> [1] \"quosure\" \"formula\"\n```\n:::\n\n\nQuosures build on formulas by adding better introspection tools, cleaner printing, and support for quasiquotation (the ability to selectively evaluate parts of an expression).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbox::use(\n    rlang[\n        quo, quo_get_expr, quo_get_env\n    ]\n)\n\nq = quo(mean(x, na.rm = TRUE))\n\nquo_get_expr(q)     # 1               \n#>> mean(x, na.rm = TRUE)\nquo_get_env(q)      # 2              \n#>> <environment: R_GlobalEnv>\nvalue = 10                            \nquo(x + !!value)    # 3         \n#>> <quosure>\n#>> expr: ^x + 10\n#>> env:  global\n```\n:::\n\n\nI can explain each commented lines: \n\n1.  You can inspect the expression thanks to `rlang::quo_get_expr()`. \n2.  You can inspect the environment thanks to `rlang::quo_get_env()`. \n3.  The `{rlang}` package provides an good API for quasiquoation, by unquoting the `value`. \n\n## Difference between \"~\" and enquo\n\nThere's some noted difference between `quo()` and `enquo()` when capturing expressions. \n\n1.  `quo()` takes the quosure of the expression you write. \n2.  `enquo()` takes the quosure of the expression taken by the user input. \n\nBoth are still quosures and inspired by formulas in R, as they return both the same classes. \n\nNow, the distinction between using raw formulas (`~`) and `enquo()` is subtle but important when building functions that accept user expressions.\n\nFor instance:\n\n1.  Using `~` captures literally in the current scope\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    my_formula = function(x) {\n        f = ~ x\n        f\n    }\n    \n    my_formula(a + b)\n    #>> ~x\n    #>> <environment: 0x000001db15d5db20>\n    ```\n    :::\n\n\n2.  `rlang::enquo()` captures what the caller passed\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    my_enquo = function(x) {\n        rlang::enquo(x)\n    }\n    \n    my_enquo(a + b)\n    #>> <quosure>\n    #>> expr: ^a + b\n    #>> env:  global\n    ```\n    :::\n\n\n::: {.callout-note title=\"General rule of thumb between `quo()` and `enquo()`\"}\nUse `enquo()` when building functions that accept user-supplied names or expressions. Use `quo()` when you're programmatically constructing expressions yourself.\n:::\n\n# Why other languages struggle with formulas\n\nPython has an attempt on emulating formulas in R, done by some libraries like `{statsmodels}`, but failed miserably due to Python's limitation. The core issue is because Python evaluates expressions eagerly, while R formulas require lazy evaluation\n\nSo to approximate (not really even close) R's formula interface, they had to use strings, which itself is a bad solution. \n\n``` python\nimport statsmodels.formula.api as smf\nmodel = smf.ols('y ~ x + I(x**2)', data=df).fit()\n```\n\nJulia has an actual R's formula interface, but there are some slight differences\n\n``` julia\nusing GLM\nlm(@formula(y ~ x + x^2), data = df)\n```\n\nThe formulas API in R is one of the reasons why some languages cannot fully integrated into other programming languages. The tight integration of:\n\n1. Lazy evaluation\n2. Environment capture  \n3. Special operator semantics\n4. Implicit data masking\n\ncreates a unique programming model that's hard to transplant. This is both R's greatest strength in statistical computing. \n\n# Further Reading\n\n- [R Language Definition: Formula Objects](https://cran.r-project.org/doc/manuals/r-release/R-lang.html)\n- [Advanced R: Metaprogramming](https://adv-r.hadley.nz/metaprogramming.html)\n- [rlang documentation](https://rlang.r-lib.org/)\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}