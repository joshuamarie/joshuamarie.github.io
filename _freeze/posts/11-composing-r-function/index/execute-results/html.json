{
  "hash": "73f3ff0e4a4fe26c62c9ef4515b62c45",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Three levels to compose R functions\"\nsubtitle: \"Intro to my functional programming series\"\ndate: \"2025-12-15\"\nimage: \"image.png\"\ncategories: [R, data-science, tidyverse, purrr, functional-programming, fp]\ndescription: \"Introducing the 3 ways to compose functions in R. \"\nformat:\n    html:\n        toc: true\n        toc-float: true\n        toc-depth: 3\n        number-sections: true\n        code-fold: false\n        code-tools: false\n        theme: default\n        fig-width: 10\n        fig-height: 6\n        fig-cap-location: bottom\n        code-annotations: hover\nexecute:\n    echo: true\n    warning: false\n    message: false\nfilters:\n    - social-share\n    - collapse-output\nshare:\n    permalink: \"https://joshuamarie.com/posts/11-composing-r-function\"\n    description: \"Three levels to compose R functions — Joshua Marie\"\n    twitter: true\n    facebook: true\n    reddit: true\n    stumble: true\n    tumblr: true\n    linkedin: true\n    email: true\n    mastodon: true\n    bsky: true\n    location: \"before-body\"\nengine: knitr\n---\n\nMaybe few people who use R have forgotten already that R is functional by heart. R has Python dogma OO system, thanks to *Reference Class* (RC) and R6. R functions can be treated as Lisp's macros, where it can let you meddle the function and *abstract syntax tree* (AST) of the function call. \n\nR has few ways to compose a function, divided by three (3) levels: \n\n1.  [Manual Typing](#manual-compose)\n2.  [Higher-order Functions](#higher-order)\n3.  [Programmatic](#program)\n\n# Level 1: Manual Composition {#manual-compose}\n\nAt the most basic level, we compose functions by manually writing them out. This is the approach most R users start with, and it's perfectly valid for many use cases.\n\n## Creating Wrapper Functions\n\nSometimes we want to reuse a composition pattern. We can manually create a wrapper function with `function` keyword:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnormalize = function(x) {\n    (x - mean(x)) / sd(x)\n}\n\ndata = c(10, 20, 30, 40, 50)\nnormalize(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -1.2649111 -0.6324555  0.0000000  0.6324555  1.2649111\n```\n\n\n:::\n:::\n\n\nWhile this level of composition is explicit, straightforward, and easy to understand, it requires writing out each function definition manually, which can become repetitive when you have many similar transformations.\n\n## Application in *functionals*\n\nMany base R and tidyverse functions are *functionals*: they take a function as input and apply it across data (e.g., `sapply()`, `purrr::map()`, `integrate()`).\n\nTo compose functions for functionals, instead of manually writing function from the outside of the call:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt2 = function(x) x^0.5\n\nsapply(1:5, sqrt2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.000000 1.414214 1.732051 2.000000 2.236068\n```\n\n\n:::\n:::\n\n\nYou can compose on the fly with anonymous functions (you can just refer it as an \"unassigned function\" if you want):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(1:5, function(x) x^0.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.000000 1.414214 1.732051 2.000000 2.236068\n```\n\n\n:::\n:::\n\n\nOr use the modern shorthand `\\()` (after 4.1):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(1:5, \\(x) x^0.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.000000 1.414214 1.732051 2.000000 2.236068\n```\n\n\n:::\n:::\n\n\nEven better — show that `\\()` is just syntactic sugar for `function()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquote(\\(x) x^2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction(x) x^2\n```\n\n\n:::\n:::\n\n\n# Level 2: Using Higher-order Functions {#higher-order}\n\nHow about we comprises the existing functions and give birth to another function? We can easily make that with `purrr::compose()`. How about we create a function out of the function? That's *function operators* in action. \n\nHigher-order functions can return new functions by combining or modifying existing ones, reducing manual code writing.\n\n## Function Composition with purrr::compose()\n\nThe nice thing about this is that it takes multiple functions and creates a single new function that applies them in sequence (the default direction is *backwards*).\n\nSo, instead of writing this manually:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransform = function(x) {\n    sqrt(mean(log(x)))\n}\n\ntransform(1:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.9785184\n```\n\n\n:::\n:::\n\n\nWe can compose it through `purrr::compose()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::compose(sqrt, mean, log)(1:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.9785184\n```\n\n\n:::\n:::\n\n\nFurthermore, this is also (almost) as readable as using pipe:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:5 |> log() |> mean() |> sqrt()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.9785184\n```\n\n\n:::\n:::\n\n\n> I have a [different blog](https://joshuamarie.com/posts/05-pipes/#the-early-days-pre-pipe-workflows-2010) mentioning on how bad can the nested function call go. \n\nThis function can be read from left to right (by default, it is read vice-versa):\n\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::compose(sqrt, mean, log, .dir = \"forward\")(1:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5166883\n```\n\n\n:::\n:::\n\n\nWhich is an equivalent of:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:5 |> sqrt() |> mean() |> log()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5166883\n```\n\n\n:::\n:::\n\n\nThis function can take the inverse: can be read from left to right (by default, it is read vice-versa):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransform_forward = purrr::compose(sqrt, mean, log, .dir = \"forward\")\ntransform_forward(1:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5166883\n```\n\n\n:::\n:::\n\n\nWhich is an equivalent of:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:5 |> sqrt() |> mean() |> log()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5166883\n```\n\n\n:::\n:::\n\n\n## Partial Application with purrr::partial()\n\nAnother function from `{purrr}` is the `purrr::partial()`, where the application is where you \"pre-fill\" some arguments of a function, creating a new function with fewer parameters. This is incredibly useful for creating specialized versions of general functions.\n\nConsider this function, where a number argument `x` is divided by 100:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndivide_by_100 = function(x) {\n    x / 100\n}\n\ndivide_by_100(500)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n:::\n\n\nWe can write as:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndivide_by_100 = purrr::partial(`/`, e2 = 100)\ndivide_by_100(500)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n:::\n\n\nIf you ask \"what's the point of partial application\", this can be particularly useful in conjunction with functionals and other function operators, and also supports `{rlang}` and NSE APIs — which means you can write it without \"typing too much\".\n\n## Function Operators in general\n\nIn case you don't know, decorators in Python are just \"function operators\" in general, except it is pretty much tied into Python and coated with syntactic sugars. \n\nFunction operators take functions as input and return modified functions as output. They're like functions that operate on the \"function space\" rather than the data space.\n\n### Example 1: \n\nFunction operators can add behavior without changing the core logic:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith_logging = function(f) {\n    function(...) {\n        cat(\"Calling function with args:\", paste(list(...), collapse = \", \"), \"\\n\")\n        res = f(...)\n        cat(\"Result:\", res, \"\\n\")\n        res\n    }\n}\n\nlogged_sqrt = with_logging(sqrt)\nlogged_sqrt(16)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCalling function with args: 16 \nResult: 4 \n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\nIf you want to do this with Python, here take a look:\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef with_logging(f):\n    def call(*args):\n        args_str = \", \".join(str(a) for a in args)\n        print(f\"Calling function with args: {args_str}\")\n        res = f(*args)\n        print(f\"Result: {res}\")\n        return res\n    \n    return call\n\n\n@with_logging\ndef logged_sqrt(x):\n    return x ** 0.5\n    \nprint(logged_sqrt(16))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCalling function with args: 16\nResult: 4.0\n4.0\n```\n\n\n:::\n:::\n\n\n### Example 2: Creating a Memoization Operator\n\nMemoization caches function results to speed up repeated calls:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmemoize = function(f) {\n    cache = new.env(parent = emptyenv())\n    \n    function(...) {\n        key = paste(list(...), collapse = \"_\")\n        if (!exists(key, envir = cache)) {\n            cache[[key]] = f(...)\n        }\n        cache[[key]]\n    }\n}\n\nslow_function = function(x) {\n    Sys.sleep(1) \n    x^2\n}\n\nfast_function = memoize(slow_function)\nsystem.time(fast_function(5))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   user  system elapsed \n   0.00    0.00    1.01 \n```\n\n\n:::\n:::\n\n\n# Level 3: Programmatic Approach {#program}\n\nSwear, this is not an easy thing to do — you need at least better understanding on how to build / generate expressions in R, and this involves understanding metaprogramming in R — Yes, most of the part on manipulating ASTs. \n\nThe `rlang::new_function()` provides an API that programmatically constructs a function expression (yes, it does creates formals, body, and an environment — 3 main components of R functions). Keep in mind that the construction of the function expression with `rlang::new_function()` happens in runtime. \n\n## Start with the basic first\n\nThe `new_function()` function takes three arguments: \n\n-   `args`: The formal arguments under that function\n-   `body`: An expression that takes the function body\n-   `env`: If supplied, this will be the parent environment of the function.  \n\nLet's start with a function that squares the number: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nbox::use(\n    rlang[new_function, expr, caller_env, call2]\n)\n\nsquare = new_function(\n    args = list(x = expr()), \n    body = call2(\"{\", quote(x^2)), \n    env = caller_env()\n)\n\nsquare(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 25\n```\n\n\n:::\n:::\n\n\nOr instead of `list()` in `args` parameter, how about using `pairlist2()` instead? \n\n\n::: {.cell}\n\n```{.r .cell-code}\nbox::use(rlang[pairlist2])\n\nsquare2 = new_function(\n    args = pairlist2(x = ), \n    body = expr(x^2), \n    env = caller_env()\n)\n\nsquare2(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 25\n```\n\n\n:::\n:::\n\n\nAlright, you might be asking: What's the point of using `new_function()` if we can just use `function()` instead? The purpose of this approach is that you can *programmatically generate functions* based on data or configuration.\n\nIn fact, this is how I *automatically* generate `torch::nn_module()` expression used in my new R package called `{kindling}`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbox::use(kindling[ffnn_generator, act_funs, args])\n\nffnn_generator(\n    nn_name = \"MyFFNN2\",\n    hd_neurons = c(128, 64, 32, 15),\n    no_x = 20,\n    no_y = 5,\n    activations = act_funs(\n        relu,\n        selu,\n        softshrink = args(lambd = 0.5),\n        \"celu(alpha = 0.5)\"\n    )\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntorch::nn_module(\"MyFFNN2\", initialize = function () \n{\n    self$fc1 = torch::nn_linear(20, 128, bias = TRUE)\n    self$fc2 = torch::nn_linear(128, 64, bias = TRUE)\n    self$fc3 = torch::nn_linear(64, 32, bias = TRUE)\n    self$fc4 = torch::nn_linear(32, 15, bias = TRUE)\n    self$out = torch::nn_linear(15, 5, bias = TRUE)\n}, forward = function (x) \n{\n    x = self$fc1(x)\n    x = torch::nnf_relu(x)\n    x = self$fc2(x)\n    x = torch::nnf_selu(x)\n    x = self$fc3(x)\n    x = torch::nnf_softshrink(x, lambd = 0.5)\n    x = self$fc4(x)\n    x = torch::nnf_celu(x, alpha = 0.5)\n    x = self$out(x)\n    x\n})\n```\n\n\n:::\n:::\n\n\nIn which, this function is a reference from this [blog post](https://joshuamarie.com/posts/01-meta-nn/) of mine quite a while ago, based on what I learned in [Advanced R](https://adv-r.hadley.nz) to automatically generate `torch::nn_module()`. \n\n# When to Use Each Approach (here are some of my guides)\n\n- **Level 1 (Manual)**: When you're prototyping, the logic is simple, or you need maximum clarity\n- **Level 2 (Higher-order)**: When you want to reuse composition patterns and keep code DRY (Don't Repeat Yourself)\n- **Level 3 (Programmatic)**: When you're building frameworks, DSLs, or need to generate many similar functions from specifications (my package `{kindling}` is one of the many example packages)\n\n# Resources\n\n-  [Advanced R by Hadley Wickham](https://adv-r.hadley.nz)\n-  [Functional Programming in R with purrr](https://purrr.tidyverse.org/)\n-  [rlang Documentation](https://rlang.r-lib.org/)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}