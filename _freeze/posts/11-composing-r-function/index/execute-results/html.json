{
  "hash": "7c832a9528106ad21d211d18a4572771",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Three levels to compose R functions\"\nsubtitle: \"Intro to my functional programming series\"\ndate: \"2025-12-15\"\nimage: \"image.png\"\ncategories: [R, data-science, tidyverse, purrr, functional-programming, fp]\ndescription: \"Introducing the 3 ways to compose functions in R. These are all my discoveries\"\nformat:\n    html:\n        toc: true\n        toc-float: true\n        toc-depth: 3\n        number-sections: true\n        code-fold: false\n        code-tools: false\n        theme: default\n        fig-width: 10\n        fig-height: 6\n        fig-cap-location: bottom\n        code-annotations: hover\nexecute:\n    echo: true\n    warning: false\n    message: false\nfilters:\n    - social-share\n    - collapse-output\nshare:\n    permalink: \"https://joshuamarie.com/posts/11-composing-r-function\"\n    description: \"Three levels to compose R functions — Joshua Marie\"\n    twitter: true\n    facebook: true\n    reddit: true\n    stumble: true\n    tumblr: true\n    linkedin: true\n    email: true\n    mastodon: true\n    bsky: true\n    location: \"before-body\"\nengine: knitr\n---\n\nMaybe few people who use R have forgotten already that R is functional by heart. R has Python dogma OO system, thanks to *Reference Class* (RC) and R6. R functions can be treated as Lisp's macros, where it can let you meddle the function and *abstract syntax tree* (AST) of the function call. \n\nR has few ways to compose a function, divided by three (3) levels: \n\n1.  [Manual Typing](#manual-compose)\n2.  [Higher-order Functions](#higher-order)\n3.  [Programmatic](#program)\n\n# Level 1: Manual Composition {#manual-compose}\n\n# Level 2: Using Higher-order Functions {#higher-order}\n\nHow about we comprises the existing functions and give birth to another function? We can easily make that with `purrr::compose()`. How about we create a function out of the function? That's *function operators* in action. \n\nHigher-order functions create new functions by combining or modifying existing ones, reducing manual code writing.\n\n## Function Composition with purrr::compose()\n\nThe nice thing about this is that it takes multiple functions and creates a single new function that applies them in sequence (the default direction is *backwards*).\n\nSo, instead of writing this manually:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransform = function(x) {\n    sqrt(mean(log(x)))\n}\ntransform(1:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.9785184\n```\n\n\n:::\n:::\n\n\nWe can compose it through `purrr::compose()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::compose(sqrt, mean, log)(1:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.9785184\n```\n\n\n:::\n:::\n\n\nFurthermore, this is also (almost) as readable as using pipe:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:5 |> log() |> mean() |> sqrt()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.9785184\n```\n\n\n:::\n:::\n\n\n> I have a [different blog](https://joshuamarie.com/posts/05-pipes/#the-early-days-pre-pipe-workflows-2010) mentioning on how bad can the nested function call go. \n\nThis function can be read from left to right (by default, it is read vice-versa):\n\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::compose(sqrt, mean, log, .dir = \"forward\")(1:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5166883\n```\n\n\n:::\n:::\n\n\nWhich is an equivalent of:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:5 |> sqrt() |> mean() |> log()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5166883\n```\n\n\n:::\n:::\n\n\n## Partial Application with purrr::partial()\n\n## Function Operators in general\n\n# Level 3: Programmatic Approach {#program}\n\nSwear, this is not easy to do — you need at least better understanding on how to build / generate expressions in R, and this involves understanding metaprogramming in R — Yes, most of the part on manipulating ASTs. \n\nThe `rlang::new_function()` provides an API that programmatically constructs a function expression (yes, it does creates formals, body, and an environment — 3 main components of R functions). Keep in mind that the construction of the function expression with `rlang::new_function()` happens in runtime. \n\n## Start with the basic first\n\nThe `new_function()` function takes three arguments: formal arguments, the function body, and optionally an environment. Let's start with a function that squares the number: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nbox::use(\n    rlang[new_function, expr, caller_env, call2]\n)\n\nsquare = new_function(\n    args = list(x = expr()), \n    body = call2(\"{\", quote(x^2)), \n    env = caller_env()\n)\nsquare(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 25\n```\n\n\n:::\n:::\n\n\nOr instead of `list()` in `args` parameter, how about using `pairlist2()` instead? \n\nAlright, you might be asking: What's the point of using `new_function()` if we can just use `function()` instead? The purpose of this\n\nAnd the thing is, you can automatically generate a function expression with this function. \n\n# Resources\n\n-  [Advanced R by Hadley Wickham](https://adv-r.hadley.nz)\n-  []()\n-  []()\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}