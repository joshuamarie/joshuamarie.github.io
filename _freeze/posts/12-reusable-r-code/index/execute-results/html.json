{
  "hash": "da0b65801c7c93f596e6603cfc1df517",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Bother yourself writing reusable codes in R, not throwaway codes\"\nsubtitle: \"Reasons and applications with box\"\ndate: \"2025-12-20\"\nimage: \"image.png\"\ncategories: [R, box, programming]\ndescription: \"I can also show you a proper way to write reusable R codes\"\nformat:\n    html:\n        toc: true\n        toc-float: true\n        toc-depth: 3\n        number-sections: true\n        code-fold: false\n        code-tools: false\n        theme: default\n        fig-width: 10\n        fig-height: 6\n        fig-cap-location: bottom\n        code-annotations: hover\nexecute:\n    echo: true\n    warning: false\n    message: false\nfilters:\n    - social-share\n    - collapse-output\nshare:\n    permalink: \"https://joshuamarie.com/posts/12-reusable-r-code\"\n    description: \"Reusable codes in R — Joshua Marie\"\n    twitter: true\n    facebook: true\n    reddit: true\n    stumble: true\n    tumblr: true\n    linkedin: true\n    email: true\n    mastodon: true\n    bsky: true\n    location: \"before-body\"\nengine: knitr\n---\n\n# The Problem with Throwaway Code\n\nWhy bother yourself writing reusable codes? R is so behind in terms of reusability and maintainability of the codes written, and I don't like the fact that there are piles of garbage codes in the wild — although other languages, even Python, is guilty at this one. \n\nIf you've been working with R for any length of time, you've probably encountered (or written) code that looks something like this:\n\n\n::: {.cell filename='analysis_final_v3_ACTUAL.R'}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\nrecords <- read_csv(\"records.csv\") # Directly import CSV files into R\n\n# Modify the records a bit\nrecords$date <- as.Date(records$date) \nrecords <- records %>% filter(!is.na(value))\n\n# Calculate some statistics\nmean_value <- mean(records$value)\nsd_value <- sd(records$value)\n\n# Then the usual records viz\nggplot(records, aes(x = date, y = value)) +\n    geom_line() +\n    theme_minimal()\n```\n:::\n\n\nThis script works, yes. It does what you need it to do right now, yes. But what happens when you need to:\n\n-   Run the same analysis on a different dataset?\n-   Share this code with a colleague?\n-   Come back to this code in six months?\n-   Use these calculations in another project?\n\nYou end up copying and pasting, making small modifications, and before you know it, you have `analysis_v1.R`, `analysis_v2.R`, `analysis_final.R`, `analysis_final_ACTUAL.R`, and `analysis_final_ACTUAL_USE_THIS_ONE.R` scattered across your projects.\n\nThis is throwaway code. It solves an immediate problem but creates long-term technical debt.\n\n# What Makes Code Reusable?\n\nReusability of the code is about writing code with intention, structure, and foresight. It shouldn't be limited about writing functions (though that helps). \n\nHere are the key characteristics:\n\n1.  ***Clear separation of concerns*** - Each piece of code should do one thing well. Data loading, cleaning, analysis, and visualization should be separate operations that can be mixed and matched.\n2.  ***Minimal dependencies*** - Your code should depend on what it actually needs, not load 20 packages \"just in case\". This helps for better long-term maintainability, and easier to understand.\n3.  ***Explicitness*** - Functions and codes in general should have clear inputs and outputs. No hidden dependencies on global variables or less mysterious side effects.\n4.  ***Documentation*** - Do not just indicate the code with comments, I recommend writing an actual documentation that explains what the code does, what it expects, and what it returns.\n\n# The Cost of Throwaway Code\n\nLet me be blunt: throwaway code is expensive. Not in terms of money (though that too), but in terms of time, mental energy, and opportunity cost.\n\n::: callout-important\n## Time Wasted on Repetition\n\nEvery time you copy-paste code and modify it slightly, you're not just duplicating code—you're duplicating bugs, duplicating maintenance burden, and duplicating the cognitive load of understanding what the code does.\n:::\n\n::: callout-important\n## Broken Knowledge Transfer\n\nWhen your colleague needs to use your analysis, they shouldn't need to reverse-engineer a 500-line script to figure out which parts are relevant to them. They shouldn't need to schedule a meeting to ask you what `temp_var_2` means.\n:::\n\n::: callout-important\n## Technical Debt Compounds\n\nThat script you wrote six months ago? The one that \"just works\"? It's now a black box. You're afraid to touch it. You build around it instead of on top of it. This is how projects become less maintainable.\n:::\n\n# Reusability in native R\n\nSo how do we write reusable code in R? R offers few functionalities, but they are too fragile and suffered with numbers of limitations. I can't recommend them enough, even for new R users. \n\n## Start with Functions\n\nEven if you think you'll only use code once, wrap it in a function. Future you will thank present you.\n\nImagine this code is repeatable:\n\n``` r \nlibrary(dplyr)\n\ndata = data %>% \n    filter(!is.na(value), value > 0)\n```\n\nInstead, minimize a bit by writing a function that does the similar, but for any data frame:\n\n\n::: {.cell filename='filter.R'}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\nretain_positive_value = function(data, var) {\n    data %>%\n        filter(!is.na({{ var }}), {{ var }} > 0)\n}\n\nretain_positive_value(data, value)\n```\n:::\n\n\n*To know more what I did, please learn more about [tidy evaluation](https://dplyr.tidyverse.org/articles/programming.html).*\n\nYou gotta have to store this function in some R script, R (and programming in general) cannot remember the codes you wrote and you execute, unless you saved the `.Rdata`, which is a big no-no. So, let's go to another step. \n\n## Sourcing a script\n\nAs you know and if you read [my previous blog](https://joshuamarie.com/posts/06-load-pkg/), I have some beefs with package import system, but I have personal beefs with code reusability in R in general. This includes \"sourcing a script\" using `source()` function. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(\"./filter.R\")\n```\n:::\n\n\nWhat's the big matter about sourcing a script with `source()`? \n\n1.   Everything from the sourced file goes into your global environment, resulting to a *namespace clash*. \n2.   **No explicit imports**: You don't know what functions you're actually using.\n3.   You need to source files in the right order.\n4.   **No encapsulation**: Functions can conflict with each other.\n\n## Creating an R Package\n\nIf reusability is the problem, I mean, you could turn every project into an R package. But it is too heavy (even the implication of R package being \"lightweight\"), sometimes overkill, and unnecessary. \n\nThat's because it:\n\n-   Requires understanding package structure\n-   Needs `DESCRIPTION`, `NAMESPACE`, and other boilerplates\n-   Must follow CRAN conventions even for internal code (sometimes this is not necessary, but it is when publishing an R package to CRAN)\n-   Overhead of package development for simple projects\n\nAnd besides, the structure of `R/` in your R package is ALWAYS flat. You can't organize modules into subdirectories naturally. \n\n# Enter {box} package\n\nI already have [a book dedicated to code reusability and module systems using `{box}` package](https://modules-in-r.joshuamarie.com/), with discussions about it. In fact, in every blog post I write, I always use `{box}` (sometimes just `::`) to qualify the imports, rather than loading an entire package and attaching all exports of that particular package. \n\nThe `{box}` package provides a \"lightweight\", modern module system for R that gives you the benefits of packages without the overhead.\n\nExample usage: \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Two ways to install this package (you can't install this package from GitHub)\"}\ninstall.packages(\"box\") \ninstall.packages('box', repos = 'https://klmr.r-universe.dev')\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbox::use(\n    dplyr,                                          # Loading the package without attaching the names\n    ./R/data_cleaning,                              # Loading an entire particular script for data cleaning from the root path\n    etl = ./R/data_cleaning,                        # Same as above but the alias was provided\n    ./R/data_cleaning[clean_data, validate_data]    # Loading some names from a particular script for data cleaning from the root path\n)\n```\n:::\n\n\nWith `{box}`, you get:\n\n- **Explicit imports**: Only load what you need\n- **Namespace isolation**: No pollution of global environment\n- **Module encapsulation**: Clear boundaries between code\n- **Simple syntax**: Easy to learn and use\n- **Hierarchical structure**: Organize modules in nested directories\n\n## Organize Your Code into Modules\n\nInstead of one giant script, break your code into bunch of R scripts as logical modules:\n\n- `data_loading.R` - Functions for reading and importing data\n- `data_cleaning.R` - Functions for cleaning and validation\n- `analysis.R` - Core analytical functions\n- `visualization.R` - Plotting functions\n\n## Use a Consistent Structure\n\nEvery project should follow a similar structure so you (and others) know where to find things. Just imagine you have a particular project:\n\n``` bash\nproject/\n├── R/\n│   ├── __init__.R       # <------ This will mark `{./R}` folder as a module\n│   ├── data_loading.R\n│   ├── data_cleaning.R\n│   ├── analysis.R\n│   └── visualization.R\n├── data/\n├── output/\n└── main.R\n```\n\n## Writing a module\n\nUnder `R/analysis.R` file, place this practical example code for the module that provides summary statistics:\n\n\n::: {.cell filename='./R/analysis.R'}\n\n```{.r .cell-code  code-fold=\"true\"}\nbox::use(\n    dplyr[\n        summarise, across, n, relocate, pick,\n        cur_group_id, matches\n    ],\n    tidyr[pivot_longer, pivot_wider]\n)\n\n#' @export\nsummary_data = function(data, vars, .by = NULL) {\n    mtcars |>\n        summarise(\n            grp_id = cur_group_id(), \n            n = n(),\n            across(\n                {{ vars }},\n                list(\n                    mean = \\(x) mean(x, na.rm = TRUE),\n                    median = \\(x) median(x, na.rm = TRUE), \n                    q25 = \\(x) quantile(x, 0.25, na.rm = TRUE),\n                    q75 = \\(x) quantile(x, 0.75, na.rm = TRUE), \n                    sd = \\(x) sd(x, na.rm = TRUE),\n                    cv = \\(x) sd(x, na.rm = TRUE) / mean(x, na.rm = TRUE),\n                    iqr = \\(x) IQR(x, na.rm = TRUE),\n                    mad = \\(x) mad(x, na.rm = TRUE)  \n                ), \n                .names = \"{.col}..{.fn}\"\n            ),\n            \n            .by = {{ .by }}\n        ) |> \n        pivot_longer(\n            cols = matches(\"\\\\.\\\\.\"), \n            names_pattern = \"(.+)\\\\.\\\\.(.+)\",  \n            names_to = c(\"variable\", \"statistic\"),\n            values_to = \"est\"\n        ) |>\n        pivot_wider(\n            names_from = statistic,\n            values_from = est\n        ) |>\n        relocate(n, .after = variable)\n}\n```\n:::\n\n\n\n::: {.cell output-fold='true' output-summary='Yes, it just works'}\n\n```{.r .cell-code}\nmtcars |> \n    summary_data(vars = c(mpg, hp, wt), .by = cyl) |> \n    knitr::kable()\n```\n\n\n\n| cyl| grp_id|variable |  n|       mean|  median|      q25|       q75|         sd|        cv|      iqr|       mad|\n|---:|------:|:--------|--:|----------:|-------:|--------:|---------:|----------:|---------:|--------:|---------:|\n|   6|      1|mpg      |  7|  19.742857|  19.700|  18.6500|  21.00000|  1.4535670| 0.0736250|  2.35000|  1.927380|\n|   6|      1|hp       |  7| 122.285714| 110.000| 110.0000| 123.00000| 24.2604911| 0.1983919| 13.00000|  7.413000|\n|   6|      1|wt       |  7|   3.117143|   3.215|   2.8225|   3.44000|  0.3563455| 0.1143180|  0.61750|  0.363237|\n|   4|      2|mpg      | 11|  26.663636|  26.000|  22.8000|  30.40000|  4.5098277| 0.1691378|  7.60000|  6.523440|\n|   4|      2|hp       | 11|  82.636364|  91.000|  65.5000|  96.00000| 20.9345300| 0.2533331| 30.50000| 32.617200|\n|   4|      2|wt       | 11|   2.285727|   2.200|   1.8850|   2.62250|  0.5695637| 0.2491827|  0.73750|  0.541149|\n|   8|      3|mpg      | 14|  15.100000|  15.200|  14.4000|  16.25000|  2.5600481| 0.1695396|  1.85000|  1.556730|\n|   8|      3|hp       | 14| 209.214286| 192.500| 176.2500| 241.25000| 50.9768855| 0.2436587| 65.00000| 44.478000|\n|   8|      3|wt       | 14|   3.999214|   3.755|   3.5325|   4.01375|  0.7594047| 0.1898885|  0.48125|  0.407715|\n:::\n\n\nNotice a few key things here:\n\n1. We only import the specific `{dplyr}` and `{tidyr}` functions we need\n2. **`#' @export` annotation**: This marks the function as public (available when the module is imported)\n3. This module has a function that does one thing: provide summary statistics\n\nThen reuse it by:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbox::use(./R/analysis[summary_data])\n\nmtcars |> \n    summary_data(vars = c(mpg, hp, wt))\n```\n:::\n\n\nYou are also allowed to import multiple functions or even the entire module:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbox::use(\n    # Import the module itself without attaching the names (access functions with summary$function_name)\n    ./analysis, \n    # Import specific names\n    ./analysis[summary_data, another_function], \n    # Attach all exported functions\n    ./analysis[...]\n)\n```\n:::\n\n\n## Document Your Functions\n\nUse `{roxygen2}`-style comments even if you're not building a package:\n\n\n::: {.cell filename='./R/analysis.R'}\n\n```{.r .cell-code  code-fold=\"true\"}\nbox::use(\n    dplyr[\n        summarise, across, n, relocate, pick,\n        cur_group_id, matches\n    ],\n    tidyr[pivot_longer, pivot_wider]\n)\n\n#' Get summary data from numeric column\n#' \n#' Calculate comprehensive summary statistics for numeric variables,\n#' including measures of central tendency, dispersion, and spread.\n#' \n#' @param data A data frame\n#' @param vars Vector of columns\n#' @param .by Optional grouping variable(s)\n#' \n#' @return A data frame with summary statistics in long format\n#' \n#' @examples \n#' mtcars |> summary_data(vars = c(mpg, hp, wt))\n#' mtcars |> summary_data(vars = c(mpg, hp), .by = cyl)\n#' \n#' @export\nsummary_data = function(data, vars, .by = NULL) {\n    mtcars |>\n        summarise(\n            grp_id = cur_group_id(), \n            n = n(),\n            across(\n                {{ vars }},\n                list(\n                    mean = \\(x) mean(x, na.rm = TRUE),\n                    median = \\(x) median(x, na.rm = TRUE), \n                    q25 = \\(x) quantile(x, 0.25, na.rm = TRUE),\n                    q75 = \\(x) quantile(x, 0.75, na.rm = TRUE), \n                    sd = \\(x) sd(x, na.rm = TRUE),\n                    cv = \\(x) sd(x, na.rm = TRUE) / mean(x, na.rm = TRUE),\n                    iqr = \\(x) IQR(x, na.rm = TRUE),\n                    mad = \\(x) mad(x, na.rm = TRUE)  \n                ), \n                .names = \"{.col}..{.fn}\"\n            ),\n            \n            .by = {{ .by }}\n        ) |> \n        pivot_longer(\n            cols = matches(\"\\\\.\\\\.\"), \n            names_pattern = \"(.+)\\\\.\\\\.(.+)\",  \n            names_to = c(\"variable\", \"statistic\"),\n            values_to = \"est\"\n        ) |>\n        pivot_wider(\n            names_from = statistic,\n            values_from = est\n        ) |>\n        relocate(n, .after = variable)\n}\n```\n:::\n\n\nAnd you can access the documentation through `box::help()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbox::use(./R/analysis)\n\nbox::help(analysis$summary_data)\n```\n:::\n\n\n# Conclusion\n\nWriting reusable code isn't about being pedantic or following rules for the sake of rules. It's about respecting your future self, your colleagues, and the craft of programming.\n\nThe `{box}` package gives R users a modern, lightweight way to organize code into reusable modules without the overhead of creating full packages. It's a middle ground that's been missing from the R ecosystem.\n\nStart small. Pick one project and try organizing it with `{box}`. You'll quickly see the benefits:\n\n- Clearer code structure\n- Easier maintenance\n- Better collaboration\n- Less time wasted on repetitive tasks\n\nYour future self will thank you. And maybe, just maybe, we can reduce the amount of garbage code in the wild.\n\n# Conclusion\n\nI don't know about you (who read this blog post), but writing reusable code isn't about being pedantic or following rules for the sake of rules. It's about respecting your future self, your colleagues, and the craft of programming.\n\nR suffers a lot of limitations in terms of reusability and maintainability. Many other programming languages' users remarks R as being an odd one, and goes to say \"it suffers for large projects\", and simply because R doesn't have a right tool. Fortunately, I can't thank `{box}` package enough by giving R users a modern, lightweight way to organize code into reusable modules without the overhead of creating full packages, similar to Python module system. It's a middle ground that's been missing from the R ecosystem.\n\nStart small. Pick one project and try organizing it with `{box}`. You'll quickly see the benefits:\n\n-   Clearer code structure\n-   Easier maintenance\n-   Better collaboration\n-   Less time wasted on repetitive tasks\n\nYour future self will thank you. And maybe, just maybe, we can reduce the amount of garbage code in the wild.\n\n# Resources\n\n- [`{box}` package documentation](https://klmr.me/box/)\n- [`{box}` GitHub repository](https://github.com/klmr/box)\n- [Box: Placing module system into R](https://modules-in-r.joshuamarie.com/)\n- [R Packages book by Hadley Wickham](https://r-pkgs.org/) - for when you're ready to go beyond modules\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}